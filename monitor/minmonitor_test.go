package monitor

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/proidiot/gone/errors"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	configutil "github.com/stuphlabs/pullcord/config/util"
	"github.com/stuphlabs/pullcord/util"
)

func getFreshLandingResponder(t *testing.T) (*url.URL, *http.Server, error) {
	l, e := net.Listen("tcp", "localhost:0")
	if e != nil {
		return nil, nil, e
	}

	uniAddr := l.Addr()
	uniAddrString := uniAddr.String()
	portOffset := strings.LastIndex(uniAddrString, ":")
	if portOffset < 0 {
		return nil, nil, fmt.Errorf(
			"Address string has unexpected format: %s",
			uniAddrString,
		)
	}
	host := uniAddrString[:portOffset]
	if host == "0.0.0.0" {
		host = "127.0.0.1"
	} else if host == "[::]" {
		host = "[::1]"
	}
	port := uniAddrString[portOffset+1:]

	u, e := url.Parse(fmt.Sprintf("http://%s:%s/", host, port))
	if e != nil {
		return nil, nil, e
	}

	s := &http.Server{
		Handler: new(util.LandingHandler),
	}

	go func(t *testing.T, s *http.Server, l net.Listener) {
		requiredErr := http.ErrServerClosed
		actualErr := s.Serve(l)
		require.Equalf(
			t,
			requiredErr,
			actualErr,
			"Unable to serve HTTP required by tests",
		)
	}(t, s, l)

	return u, s, nil
}

func getUpService(t *testing.T) (*url.URL, *http.Server, error) {
	// TODO recycle services
	return getFreshLandingResponder(t)
}

func recycleUpService(s *http.Server) {
	// TODO recycle services
	_ = s.Close()
}

func getTCPTimeout() (time.Duration, error) {
	tcpTimeoutFile, err := os.Open(
		"/proc/sys/net/ipv4/tcp_fin_timeout",
	)
	defer func() {
		_ = tcpTimeoutFile.Close()
	} ()
	if err != nil {
		return 0, err
	}

	tcpTimeoutReader := bufio.NewReader(tcpTimeoutFile)
	line, err := tcpTimeoutReader.ReadString('\n')
	if err != nil {
		return 0, err
	}

	line = line[:len(line)-1]
	tcpTimeout, err := strconv.Atoi(line)
	if err != nil {
		return 0, err
	}

	sleepSeconds := tcpTimeout + 1
	return time.ParseDuration(
		fmt.Sprintf("%ds", sleepSeconds),
	)
}

var _downService *url.URL

func getDownService(t *testing.T) (*url.URL, error) {
	if _downService == nil {
		u, e := url.Parse("//127.0.0.1:2")
		if e != nil {
			return nil, e
		}
		_downService = u
		/*
			u, s, e := getUpService(t)
			if e != nil {
				return nil, e
			}
			s.Close()

			d, e := getTCPTimeout()
			if e != nil {
				return nil, e
			}
			t.Logf(
				"Sleeping for %s so that the test socket can close",
				d.String(),
			)
			time.Sleep(d)

			_downService = u
		*/
	}

	return _downService, nil
}

// TestMinMonitorUpService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorUpService(t *testing.T) {
	testServiceName := "test"
	gracePeriod := time.Duration(0)

	u, s, err := getUpService(t)
	require.NoError(t, err)
	defer recycleUpService(s)

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is down.
func TestMinMonitorDownService(t *testing.T) {
	testServiceName := "test"
	gracePeriod := time.Duration(0)

	u, err := getDownService(t)
	assert.NoError(t, err)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorInvalidService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is invalid.
func TestMinMonitorInvalidService(t *testing.T) {
	testServiceName := "test"

	u, err := url.Parse("//127.0.0.1:80")
	assert.NoError(t, err)
	u.Host = "256.256.256.256.256:65536"

	gracePeriod := time.Duration(0)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.False(t, up)
}

// TestMinMonitorUpReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a good reprobe.
func TestMinMonitorUpReprobe(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a failed reprobe.
func TestMinMonitorDownReprobe(t *testing.T) {
	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a seemingly down service
// that is specifically indicated as being up.
func TestMinMonitorSetStatusUp(t *testing.T) {
	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	// an amount of time longer than it will take to do successive reprobes
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)

	err = mon.SetStatusUp(testServiceName)
	assert.NoError(t, err)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorFalsePositive verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is goes down
// but is reprobed within the grace period.
func TestMinMonitorFalsePositive(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)

	// an amount of time longer than it will take to do successive reprobes
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	err = s.Close()
	assert.NoError(t, err)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorTrueNegative verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorTrueNegative(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	err = s.Close()
	assert.NoError(t, err)

	// The socket is kept open for an amount of time after being prompted
	// to close in case any more TCP packets show up. Unfortunately we'll
	// just have to wait.
	sleepDuration, err := getTCPTimeout()
	require.NoError(t, err)
	t.Logf(
		"Sleeping for %s so that the test socket can close",
		sleepDuration.String(),
	)
	time.Sleep(sleepDuration)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantStatus verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is
// unspecified.
func TestMinMonitorNonExistantStatus(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status during an attempt to explicitly
// set an up state for a service that is unspecified.
func TestMinMonitorNonExistantSetStatusUp(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	err := mon.SetStatusUp(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
}

// TestMinMonitorNonExistantReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status during a reprobe attempt for a
// service that is unspecified.
func TestMinMonitorNonExistantReprobe(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	up, err := mon.Reprobe(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorAddExistant verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status when attempting to add two
// monitored services with the same name.
func TestMinMonitorAddExistant(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	u2, err := url.Parse(fmt.Sprintf("%s0", u.String()))
	assert.NoError(t, err)

	svc2, err := NewMinMonitorredService(
		u2,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	err = mon.Add(
		testServiceName,
		svc2,
	)
	assert.Error(t, err)
	assert.Equal(t, DuplicateServiceRegistrationError, err)
}

func TestMonitorFilterUp(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(testServiceName)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 200, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Pullcord Landing Page"),
		"content is: "+string(contents),
	)
}

func TestMonitorFilterDown(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		nil,
		nil,
		nil,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(testServiceName)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 503, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Service Not Ready"),
		"content is: "+string(contents),
	)
}

func TestMonitorFilterBadServiceName(t *testing.T) {
	mon := MinMonitor{}
	_, err := mon.NewMinMonitorFilter("unknown_service")
	assert.Error(t, err)
}

type counterTriggerrer struct {
	count int
}

func (th *counterTriggerrer) Trigger() error {
	if th.count < 0 {
		return errors.New("this trigger always errors")
	}

	th.count += 1
	return nil
}

func TestMonitorFilterUpTriggers(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		onDown,
		onUp,
		always,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 200, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Pullcord Landing Page"),
		"content is: "+string(contents),
	)
	assert.Equal(t, 0, onDown.count)
	assert.Equal(t, 1, onUp.count)
	assert.Equal(t, 1, always.count)
}

func TestMonitorFilterDownTriggers(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		onDown,
		onUp,
		always,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 503, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Service Not Ready"),
		"content is: "+string(contents),
	)
	assert.Equal(t, 1, onDown.count)
	assert.Equal(t, 0, onUp.count)
	assert.Equal(t, 1, always.count)
}

func TestMonitorFilterUpOnUpTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{-1}
	always := &counterTriggerrer{}

	service, err := NewMinMonitorredService(
		u,
		gracePeriod,
		onDown,
		onUp,
		always,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, onUp.count)
}

func TestMonitorFilterDownOnDownTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{-1}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		onDown,
		onUp,
		always,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, onDown.count)
}

func TestMonitorFilterDownAlwaysTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{-1}

	svc, err := NewMinMonitorredService(
		u,
		gracePeriod,
		onDown,
		onUp,
		always,
	)
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, always.count)
}

func TestMinMonitorFromConfig(t *testing.T) {
	test := configutil.ConfigTest{
		ResourceType: "minmonitorredservice",
		SyntacticallyBad: []configutil.ConfigTestData{
			{
				Data:        "",
				Explanation: "empty config",
			},
			{
				Data:        "{}",
				Explanation: "empty object",
			},
			{
				Data:        "null",
				Explanation: "null config",
			},
			{
				Data:        "42",
				Explanation: "numeric config",
			},
		},
		Good: []configutil.ConfigTestData{
			{
				Data: `{
					"address": "127.0.0.1",
					"port": 80,
					"protocol": "http",
					"graceperiod": "1s"
				}`,
				Explanation: "basic valid monitor config",
			},
		},
	}
	test.Run(t)
}
